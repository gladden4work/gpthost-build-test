name: GPTHost Build Pipeline (Minimal)

on:
  workflow_dispatch:
    inputs:
      project_id:
        description: Project ID
        required: true
        type: string
      source_files:
        description: JSON object of files (path -> content)
        required: true
        type: string
      callback_url:
        description: Worker v2 callback URL
        required: true
        type: string
      callback_token:
        description: Bearer token for callback
        required: true
        type: string
      framework:
        description: react|vue|svelte|plain
        required: false
        type: string
      build_command:
        description: Custom build command (optional)
        required: false
        type: string

permissions:
  contents: read

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Ensure jq and awscli
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi
          if ! command -v aws >/dev/null 2>&1; then
            curl -fsSL https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip -o awscliv2.zip
            unzip -q awscliv2.zip
            sudo ./aws/install
          fi

      - name: Prepare workspace
        run: |
          set -euo pipefail
          mkdir -p "projects/${{ inputs.project_id }}/src"
          mkdir -p "projects/${{ inputs.project_id }}/public"
          mkdir -p "artifacts/${{ inputs.project_id }}"

      - name: Materialize source files
        working-directory: projects/${{ inputs.project_id }}
        env:
          SOURCE_FILES: ${{ inputs.source_files }}
        run: |
          set -euo pipefail
          echo "$SOURCE_FILES" > source.json
          jq -e . source.json >/dev/null
          jq -r 'to_entries[] | @base64' source.json | while read -r row; do
            key=$(echo "$row" | base64 --decode | jq -r '.key')
            content=$(echo "$row" | base64 --decode | jq -r '.value')
            key="${key#./}"
            if [[ "$key" == *".."* ]]; then
              echo "Skipping unsafe path: $key" >&2
              continue
            fi
            target="$key"
            case "$key" in
              public/*|src/*|index.html) ;;
              *) target="src/$key" ;;
            esac
            mkdir -p "$(dirname "$target")"
            printf "%s" "$content" > "$target"
            echo "Created: $target"
          done
          if [ ! -f index.html ]; then
            cat > index.html <<'HTML'
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GPTHost Minimal</title>
  </head>
  <body>
    <div id="root">GPTHost Minimal Build</div>
  </body>
</html>
HTML
          fi

      - name: Setup Node for frameworks
        if: ${{ contains('react vue svelte', inputs.framework) }}
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Build (Vite or minimal)
        working-directory: projects/${{ inputs.project_id }}
        run: |
          set -euo pipefail
          FRAMEWORK="${{ inputs.framework }}"
          if [ -n "$FRAMEWORK" ] && [[ "$FRAMEWORK" =~ ^(react|vue|svelte)$ ]]; then
            if [ ! -f package.json ]; then
              case "$FRAMEWORK" in
                react)
                  cat > package.json <<'JSON'
{
  "name": "gpthost-app",
  "private": true,
  "scripts": { "build": "vite build" },
  "dependencies": { "react": "^18.3.1", "react-dom": "^18.3.1" },
  "devDependencies": { "vite": "^5.4.8", "@vitejs/plugin-react": "^4.3.1" }
}
JSON
                  ;;
                vue)
                  cat > package.json <<'JSON'
{
  "name": "gpthost-app",
  "private": true,
  "scripts": { "build": "vite build" },
  "dependencies": { "vue": "^3.4.0" },
  "devDependencies": { "vite": "^5.4.8", "@vitejs/plugin-vue": "^5.1.4" }
}
JSON
                  ;;
                svelte)
                  cat > package.json <<'JSON'
{
  "name": "gpthost-app",
  "private": true,
  "scripts": { "build": "vite build" },
  "dependencies": { "svelte": "^4.2.0" },
  "devDependencies": { "vite": "^5.4.8", "@sveltejs/vite-plugin-svelte": "^3.0.2" }
}
JSON
                  ;;
              esac
            fi
            if [ ! -f vite.config.js ] && [ ! -f vite.config.ts ]; then
              case "$FRAMEWORK" in
                react)
                  cat > vite.config.js <<'JS'
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
export default defineConfig({ plugins: [react()], build: { outDir: 'dist', emptyOutDir: true } })
JS
                  ;;
                vue)
                  cat > vite.config.js <<'JS'
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
export default defineConfig({ plugins: [vue()], build: { outDir: 'dist', emptyOutDir: true } })
JS
                  ;;
                svelte)
                  cat > vite.config.js <<'JS'
import { defineConfig } from 'vite'
import { svelte } from '@sveltejs/vite-plugin-svelte'
export default defineConfig({ plugins: [svelte()], build: { outDir: 'dist', emptyOutDir: true } })
JS
                  ;;
              esac
            fi
            if [ "$FRAMEWORK" = "react" ] && [ ! -f src/main.jsx ]; then
              mkdir -p src
              cat > src/main.jsx <<'JS'
import React from 'react'
import { createRoot } from 'react-dom/client'
function App(){ return React.createElement('div', null, 'GPTHost React Build') }
createRoot(document.getElementById('root')).render(React.createElement(App))
JS
              if ! grep -q 'src/main.jsx' index.html; then
                sed -i 's#</body>#  <script type="module" src="/src/main.jsx"></script>\n</body>#' index.html || true
              fi
            fi
            npm ci || npm install --no-audit --no-fund
            if [ -n "${{ inputs.build_command }}" ]; then
              bash -lc "${{ inputs.build_command }}"
            else
              npm run build
            fi
          else
            rm -rf dist
            mkdir -p dist
            cp -f index.html dist/index.html
            [ -d public ] && cp -r public/. dist/
            [ -d src ] && mkdir -p dist/src && cp -r src/. dist/src/
          fi

      - name: Prepare artifacts
        run: |
          set -euo pipefail
          cp -r "projects/${{ inputs.project_id }}/dist/." "artifacts/${{ inputs.project_id }}/"
          test -f "artifacts/${{ inputs.project_id }}/index.html"

      - name: Upload to Cloudflare R2 (canonical path)
        working-directory: artifacts/${{ inputs.project_id }}
        env:
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          R2_BUCKET_NAME: ${{ secrets.R2_BUCKET_NAME }}
        run: |
          set -euo pipefail
          ENDPOINT="https://${CLOUDFLARE_ACCOUNT_ID}.r2.cloudflarestorage.com"
          export AWS_ACCESS_KEY_ID="$R2_ACCESS_KEY_ID"
          export AWS_SECRET_ACCESS_KEY="$R2_SECRET_ACCESS_KEY"
          export AWS_DEFAULT_REGION="auto"
          DEST="s3://$R2_BUCKET_NAME/builds/${{ inputs.project_id }}/dist/"
          aws s3 sync . "$DEST" --endpoint-url "$ENDPOINT" --region auto --no-progress

      - name: Success callback (auto-deploy)
        env:
          CALLBACK_URL: ${{ inputs.callback_url }}
          CALLBACK_TOKEN: ${{ inputs.callback_token }}
        run: |
          set -euo pipefail
          BODY=$(jq -n \
            --arg status "success" \
            --arg pid "${{ inputs.project_id }}" \
            --arg rid "${{ github.run_id }}" \
            --arg run_url "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            --arg r2_path "builds/${{ inputs.project_id }}/dist/" \
            '{status:$status, project_id:$pid, github_run_id:$rid, github_run_url:$run_url, r2_build_path:$r2_path}')
          curl -sS -X POST "$CALLBACK_URL" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $CALLBACK_TOKEN" \
            -d "$BODY"

      - name: Failure callback
        if: failure()
        env:
          CALLBACK_URL: ${{ inputs.callback_url }}
          CALLBACK_TOKEN: ${{ inputs.callback_token }}
        run: |
          set -euo pipefail
          BODY=$(jq -n \
            --arg status "failure" \
            --arg pid "${{ inputs.project_id }}" \
            --arg rid "${{ github.run_id }}" \
            --arg run_url "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            '{status:$status, project_id:$pid, github_run_id:$rid, github_run_url:$run_url}')
          curl -sS -X POST "$CALLBACK_URL" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $CALLBACK_TOKEN" \
            -d "$BODY"
