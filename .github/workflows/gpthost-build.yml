name: GPTHost Build Pipeline

on:
  workflow_dispatch:
    inputs:
      project_id:
        description: 'Project ID'
        required: true
        type: string
      source_files:
        description: 'Source files as JSON object'
        required: true
        type: string
      build_config:
        description: 'Build configuration (package.json content)'
        required: true
        type: string
      callback_url:
        description: 'Callback URL for build status'
        required: true
        type: string
      callback_token:
        description: 'Authentication token for callback'
        required: true
        type: string

env:
  NODE_VERSION: '20'
  PROJECT_ID: ${{ inputs.project_id }}
  CALLBACK_URL: ${{ inputs.callback_url }}
  CALLBACK_TOKEN: ${{ inputs.callback_token }}
  CACHE_VERSION: ${{ vars.CACHE_VERSION || '1' }}

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 1

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        registry-url: 'https://registry.npmjs.org'

    # Ensure jq is available for JSON processing used later
    - name: Install jq
      run: |
        sudo apt-get update
        sudo apt-get install -y jq

    # FIX: Create cache directories before cache steps (CRITICAL FIX)
    - name: Create cache directories
      run: mkdir -p projects/${{ inputs.project_id }}

    # TASK-027: Multi-level cache strategy for build optimization (FIXED)
    - name: Cache node_modules (Level 1 - Exact Dependencies)
      id: cache-node-modules-exact
      uses: actions/cache@v4
      with:
        path: |
          projects/${{ inputs.project_id }}/node_modules
          ~/.npm
        key: node-modules-v${{ env.CACHE_VERSION }}-${{ runner.os }}-${{ inputs.project_id }}-${{ hashFiles('projects/${{ inputs.project_id }}/package-lock.json') }}
        restore-keys: |
          node-modules-v${{ env.CACHE_VERSION }}-${{ runner.os }}-${{ inputs.project_id }}-${{ hashFiles('projects/${{ inputs.project_id }}/package.json') }}
          node-modules-v${{ env.CACHE_VERSION }}-${{ runner.os }}-${{ inputs.project_id }}-

    - name: Cache npm global packages (Level 2 - Global Cache)
      uses: actions/cache@v4
      with:
        path: ~/.npm
        key: npm-cache-v${{ env.CACHE_VERSION }}-${{ runner.os }}-${{ inputs.project_id }}-${{ hashFiles('projects/${{ inputs.project_id }}/package-lock.json') }}
        restore-keys: |
          npm-cache-v${{ env.CACHE_VERSION }}-${{ runner.os }}-${{ inputs.project_id }}-${{ hashFiles('projects/${{ inputs.project_id }}/package.json') }}
          npm-cache-v${{ env.CACHE_VERSION }}-${{ runner.os }}-${{ inputs.project_id }}-

    - name: Cache framework dependencies (Level 3 - Framework Cache)
      uses: actions/cache@v4
      with:
        path: |
          projects/${{ inputs.project_id }}/node_modules/.cache
          projects/${{ inputs.project_id }}/node_modules/.vite
        key: framework-cache-v${{ env.CACHE_VERSION }}-${{ runner.os }}-${{ inputs.project_id }}-${{ hashFiles('projects/${{ inputs.project_id }}/package.json') }}
        restore-keys: |
          framework-cache-v${{ env.CACHE_VERSION }}-${{ runner.os }}-${{ inputs.project_id }}-
          framework-cache-v${{ env.CACHE_VERSION }}-${{ runner.os }}-

    - name: Create project directory
      run: |
        echo "Creating project directory structure..."
        mkdir -p projects/${{ inputs.project_id }}/src
        mkdir -p projects/${{ inputs.project_id }}/public
        mkdir -p artifacts/${{ inputs.project_id }}
        
        echo "Project directory created successfully"
        ls -la projects/

    # FIX 1: Add missing source file creation step (CRITICAL FIX)
    - name: Create source files
      working-directory: projects/${{ inputs.project_id }}
      env:
        SOURCE_FILES: ${{ inputs.source_files }}
        BUILD_CONFIG: ${{ inputs.build_config }}
      run: |
        echo "Creating source files from input..."
        # Robust approach: write entries to a temp file to avoid process substitution or YAML expression issues
        printf '%s' "$SOURCE_FILES" | jq -r 'to_entries[] | @base64' > .entries
        
        while IFS= read -r entry; do
          key=$(printf '%s' "$entry" | base64 -d | jq -r '.key')
          content=$(printf '%s' "$entry" | base64 -d | jq -r '.value')
          mkdir -p "$(dirname "src/$key")"
          printf '%s' "$content" > "src/$key"
          echo "Created: src/$key"
        done < .entries
        
        # FIX 3: Create package.json from build_config input (CRITICAL FIX)
        echo "Creating package.json..."
        # Write build_config to package.json using env var to avoid YAML expression issues
        printf '%s' "$BUILD_CONFIG" > package.json
        
        # Validate JSON
        if ! jq . package.json > /dev/null 2>&1; then
          echo 'ERROR: Invalid build_config JSON'
          exit 1
        fi
        
        echo "Source files and package.json created successfully"
        ls -la src/
        ls -la

    - name: Validate project structure
      working-directory: projects/${{ inputs.project_id }}
      run: |
        echo "Validating project structure..."
        
        # Check if package.json exists and is valid
        if [ ! -f "package.json" ]; then
          echo "ERROR: package.json not found"
          exit 1
        fi
        
        # Validate JSON syntax
        if ! jq . package.json > /dev/null 2>&1; then
          echo "ERROR: Invalid JSON in package.json"
          cat package.json
          exit 1
        fi
        
        # Check if source files exist
        if [ ! -d "src" ] || [ -z "$(ls -A src)" ]; then
          echo "ERROR: No source files found in src directory"
          exit 1
        fi
        
        echo "Project structure validation passed"
        echo "Package.json contents:"
        cat package.json
        echo "Source files:"
        find src -type f

    # TASK-027: Install dependencies with cache optimization and metrics tracking
    - name: Install dependencies with cache optimization
      working-directory: projects/${{ inputs.project_id }}
      run: |
        echo "ðŸš€ Installing dependencies with cache optimization..."
        
        # Record start time for metrics
        INSTALL_START_TIME=$(date +%s)
        
        # Check cache hit status
        echo "ðŸ“Š Cache Hit Analysis:"
        if [ "${{ steps.cache-node-modules-exact.outputs.cache-hit }}" = "true" ]; then
          echo "âœ… NODE_MODULES_CACHE_HIT=true"
          echo "âœ… Exact node_modules cache hit - dependencies restored from cache"
          CACHE_HIT_TYPE="exact"
        else
          echo "âŒ NODE_MODULES_CACHE_HIT=false"
          echo "âš¡ Installing dependencies from npm registry..."
          CACHE_HIT_TYPE="miss"
        fi
        
        # Set environment variables for metrics
        echo "CACHE_HIT_TYPE=$CACHE_HIT_TYPE" >> $GITHUB_ENV
        echo "INSTALL_START_TIME=$INSTALL_START_TIME" >> $GITHUB_ENV
        
        # Optimize npm install based on cache status
        if [ "${{ steps.cache-node-modules-exact.outputs.cache-hit }}" = "true" ]; then
          echo "ðŸŽ¯ Using cached node_modules - running npm install with --prefer-offline"
          npm install --production=false --prefer-offline --no-audit --no-fund
        else
          echo "ðŸ“¦ Full dependency installation - using npm install"
          npm install --production=false --no-audit --no-fund --timing
        fi
        
        # Record completion time and calculate metrics
        INSTALL_END_TIME=$(date +%s)
        INSTALL_DURATION=$((INSTALL_END_TIME - INSTALL_START_TIME))
        
        echo "INSTALL_DURATION=$INSTALL_DURATION" >> $GITHUB_ENV
        echo "INSTALL_END_TIME=$INSTALL_END_TIME" >> $GITHUB_ENV
        
        echo "ðŸ“ˆ Installation Metrics:"
        echo "   Cache Hit Type: $CACHE_HIT_TYPE"
        echo "   Installation Duration: ${INSTALL_DURATION}s"
        echo "   Dependencies Count: $(find node_modules -maxdepth 1 -type d | wc -l)"
        echo "   node_modules Size: $(du -sh node_modules 2>/dev/null | cut -f1 || echo 'N/A')"
        
        echo "âœ… Dependencies installed successfully"

    - name: Create build configuration
      working-directory: projects/${{ inputs.project_id }}
      env:
        BUILD_CONFIG: ${{ inputs.build_config }}
      run: |
        echo "Setting up build environment..."
        
        # Ensure root index.html exists for Vite (required entry point)
        if [ ! -f "index.html" ]; then
          cat > index.html << 'EOF'
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="UTF-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1.0" />
            <title>GPTHost Component</title>
          </head>
          <body>
            <div id="root"></div>
            <script type="module" src="/src/main.jsx"></script>
          </body>
        </html>
        EOF
        fi
        
        # Also provide public/index.html for frameworks expecting a public folder
        if [ ! -f "public/index.html" ]; then
          mkdir -p public
          cat > public/index.html << 'EOF'
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="UTF-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1.0" />
            <title>GPTHost Component</title>
          </head>
          <body>
            <div id="root"></div>
          </body>
        </html>
        EOF
        fi
        
        # Create vite config if it doesn't exist
        if [ ! -f "vite.config.js" ] && [ ! -f "vite.config.ts" ]; then
          cat > vite.config.js << 'EOF'
        import { defineConfig } from 'vite'
        import react from '@vitejs/plugin-react'

        export default defineConfig({
          plugins: [react()],
          build: {
            outDir: 'dist',
            emptyOutDir: true
          }
        })
        EOF
        fi
        
        echo "Build configuration created"

    # TASK-027: Build project with performance metrics and cache-aware optimization
    - name: Build project with performance tracking
      working-directory: projects/${{ inputs.project_id }}
      run: |
        echo "ðŸ—ï¸ Starting build process with performance tracking..."
        
        # Record build start time
        BUILD_START_TIME=$(date +%s)
        
        # Set environment variables for build optimization
        export NODE_ENV=production
        export CI=true
        export VITE_USE_CACHED_DEPS=true
        
        echo "ðŸ“Š Build Environment:"
        echo "   Node Version: $(node --version)"
        echo "   NPM Version: $(npm --version)"
        echo "   Cache Hit Type: $CACHE_HIT_TYPE"
        echo "   Install Duration: ${INSTALL_DURATION}s"
        
        # Run build command with cache-aware optimizations
        echo "âš¡ Running optimized build process..."
        if npm run build; then
          echo "âœ… Build completed successfully"
        else
          echo "âŒ Build failed"
          exit 1
        fi
        
        # Record build completion time and calculate metrics
        BUILD_END_TIME=$(date +%s)
        BUILD_DURATION=$((BUILD_END_TIME - BUILD_START_TIME))
        TOTAL_DURATION=$((BUILD_END_TIME - INSTALL_START_TIME))
        
        # Set metrics environment variables for callback
        echo "BUILD_START_TIME=$BUILD_START_TIME" >> $GITHUB_ENV
        echo "BUILD_END_TIME=$BUILD_END_TIME" >> $GITHUB_ENV
        echo "BUILD_DURATION=$BUILD_DURATION" >> $GITHUB_ENV
        echo "TOTAL_DURATION=$TOTAL_DURATION" >> $GITHUB_ENV
        
        # Verify build output
        if [ ! -d "dist" ] || [ -z "$(ls -A dist)" ]; then
          echo "âŒ ERROR: No build output found in dist directory"
          exit 1
        fi
        
        # Calculate build artifacts metrics
        ARTIFACTS_COUNT=$(find dist -type f | wc -l)
        ARTIFACTS_SIZE=$(du -sh dist 2>/dev/null | cut -f1 || echo 'N/A')
        
        echo "ARTIFACTS_COUNT=$ARTIFACTS_COUNT" >> $GITHUB_ENV
        echo "ARTIFACTS_SIZE=$ARTIFACTS_SIZE" >> $GITHUB_ENV
        
        echo "ðŸ“ˆ Build Performance Metrics:"
        echo "   Cache Hit Type: $CACHE_HIT_TYPE"
        echo "   Install Duration: ${INSTALL_DURATION}s"
        echo "   Build Duration: ${BUILD_DURATION}s"
        echo "   Total Duration: ${TOTAL_DURATION}s"
        echo "   Artifacts Count: $ARTIFACTS_COUNT"
        echo "   Artifacts Size: $ARTIFACTS_SIZE"
        
        # Performance target check
        if [ "$TOTAL_DURATION" -lt 30 ]; then
          echo "ðŸŽ¯ âœ… Performance target achieved: ${TOTAL_DURATION}s < 30s"
          echo "PERFORMANCE_TARGET_MET=true" >> $GITHUB_ENV
        else
          echo "âš ï¸ Performance target missed: ${TOTAL_DURATION}s >= 30s"
          echo "PERFORMANCE_TARGET_MET=false" >> $GITHUB_ENV
        fi
        
        echo "âœ… Build verification passed"
        ls -la dist/

    - name: Prepare artifacts
      run: |
        echo "Preparing artifacts for upload..."
        
        # Copy build output to artifacts directory
        cp -r projects/${{ inputs.project_id }}/dist/* artifacts/${{ inputs.project_id }}/
        
        # Create build manifest that deployment manager expects
        BUILD_ARTIFACTS=$(find . -type f -name "*.js" -o -name "*.css" -o -name "*.html" -o -name "*.json" | while read file; do
          HASH=$(sha256sum "$file" | cut -d' ' -f1)
          SIZE=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null || echo 0)
          CONTENT_TYPE="text/plain"
          case "$file" in
            *.html) CONTENT_TYPE="text/html" ;;
            *.js) CONTENT_TYPE="application/javascript" ;;
            *.css) CONTENT_TYPE="text/css" ;;
            *.json) CONTENT_TYPE="application/json" ;;
          esac
          echo "{\"path\":\"${file#./}\",\"hash\":\"$HASH\",\"size\":$SIZE,\"contentType\":\"$CONTENT_TYPE\",\"compressed\":false}"
        done | paste -sd "," -)
        
        cat > artifacts/${{ inputs.project_id }}/manifest.json << EOF
        {
          "project_id": "${{ inputs.project_id }}",
          "build_timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "git_commit": "${{ github.sha }}",
          "workflow_run": "${{ github.run_id }}",
          "artifacts": [$BUILD_ARTIFACTS]
        }
        EOF
        
        echo "Artifacts prepared successfully"
        ls -la artifacts/${{ inputs.project_id }}/

    - name: Setup Cloudflare CLI
      run: |
        echo "Installing Cloudflare CLI..."
        npm install -g wrangler
        wrangler --version

    # FIX 4: Correct R2 upload directory path (CRITICAL FIX)
    - name: Upload to Cloudflare R2
      working-directory: artifacts/${{ inputs.project_id }}
      env:
        CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        R2_BUCKET_NAME: ${{ secrets.R2_BUCKET_NAME }}  # This should be set to BUILDS_BUCKET (e.g., 'gpthost-builds-staging')
      run: |
        echo "Uploading artifacts to Cloudflare R2..."
        
        # Set build path for callback - use correct path format expected by deployment manager
        BUILD_TIMESTAMP="$(date -u +%Y%m%d-%H%M%S)"
        BUILD_PATH="projects/${{ inputs.project_id }}/builds/$BUILD_TIMESTAMP"
        echo "BUILD_PATH=$BUILD_PATH" >> $GITHUB_ENV
        echo "BUILD_TIMESTAMP=$BUILD_TIMESTAMP" >> $GITHUB_ENV
        
        # Upload all files to R2
        for file in *; do
          if [ -f "$file" ]; then
            echo "Uploading: $file"
            wrangler r2 object put "$R2_BUCKET_NAME/$BUILD_PATH/$file" --file "$file"
          fi
        done
        
        echo "Upload to R2 completed successfully"
        echo "Artifacts available at: $BUILD_PATH"

    # TASK-027: Send success callback with comprehensive cache and performance metrics
    - name: Send success callback with cache metrics
      if: success()
      run: |
        echo "ðŸ“¡ Sending success callback with cache and performance metrics..."
        
        # Calculate cache hit rate for this build
        if [ "$CACHE_HIT_TYPE" = "exact" ]; then
          CACHE_HIT_RATE=100
        else
          CACHE_HIT_RATE=0
        fi
        
        curl -X POST "${{ inputs.callback_url }}" \
          -H "Content-Type: application/json" \
          -H "Authorization: Bearer ${{ inputs.callback_token }}" \
          -d "{
            \"status\": \"completed\",
            \"project_id\": \"${{ inputs.project_id }}\",
            \"r2_build_path\": \"$BUILD_PATH\",
            \"build_timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",
            \"artifacts_count\": $ARTIFACTS_COUNT,
            \"workflow_run_id\": \"${{ github.run_id }}\",
            \"git_commit\": \"${{ github.sha }}\",
            \"performance_metrics\": {
              \"total_duration_seconds\": $TOTAL_DURATION,
              \"install_duration_seconds\": $INSTALL_DURATION,
              \"build_duration_seconds\": $BUILD_DURATION,
              \"performance_target_met\": $PERFORMANCE_TARGET_MET,
              \"artifacts_size\": \"$ARTIFACTS_SIZE\"
            },
            \"cache_metrics\": {
              \"cache_hit_type\": \"$CACHE_HIT_TYPE\",
              \"cache_hit_rate_percent\": $CACHE_HIT_RATE,
              \"node_modules_cache_hit\": ${{ steps.cache-node-modules-exact.outputs.cache-hit == 'true' }},
              \"npm_cache_enabled\": true,
              \"framework_cache_enabled\": true
            },
            \"build_optimization\": {
              \"caching_strategy\": \"multi-level\",
              \"npm_optimization_flags\": [\"--no-audit\", \"--no-fund\", \"--prefer-offline\"],
              \"vite_cache_enabled\": true,
              \"performance_target_seconds\": 30
            }
          }"
        
        echo "âœ… Success callback with metrics sent"
        echo "ðŸ“ˆ Build Summary:"
        echo "   Total Duration: ${TOTAL_DURATION}s"
        echo "   Cache Hit Rate: ${CACHE_HIT_RATE}%"
        echo "   Performance Target Met: $PERFORMANCE_TARGET_MET"

    - name: Send failure callback
      if: failure()
      run: |
        echo "Sending failure callback..."
        
        # FIX 2: Correct JSON syntax - remove single quotes (CRITICAL FIX) 
        curl -X POST "${{ inputs.callback_url }}" \
          -H "Content-Type: application/json" \
          -H "Authorization: Bearer ${{ inputs.callback_token }}" \
          -d "{
            \"status\": \"failed\",
            \"project_id\": \"${{ inputs.project_id }}\",
            \"error_message\": \"Build pipeline failed. Check workflow logs for details.\",
            \"build_timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",
            \"workflow_run_id\": \"${{ github.run_id }}\",
            \"git_commit\": \"${{ github.sha }}\"
          }"
        
        echo "Failure callback sent"

  cleanup:
    runs-on: ubuntu-latest
    if: always()
    needs: build
    steps:
    - name: Cleanup temporary files
      run: |
        echo "Cleaning up temporary build files..."
        # This step runs regardless of build success/failure
        # to ensure we don't leave temporary artifacts
        echo "Cleanup completed"
