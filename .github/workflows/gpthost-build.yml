name: GPTHost Build Pipeline - FIXED

on:
  workflow_dispatch:
    inputs:
      project_id:
        description: 'Project ID'
        required: true
        type: string
      source_files:
        description: 'Source files as JSON object'
        required: true
        type: string
      build_config:
        description: 'Build configuration (package.json content)'
        required: true
        type: string
      callback_url:
        description: 'Callback URL for build status'
        required: true
        type: string
      callback_token:
        description: 'Authentication token for callback'
        required: true
        type: string

env:
  NODE_VERSION: '20'
  PROJECT_ID: ${{ inputs.project_id }}
  CALLBACK_URL: ${{ inputs.callback_url }}
  CALLBACK_TOKEN: ${{ inputs.callback_token }}
  CACHE_VERSION: ${{ vars.CACHE_VERSION || '1' }}
  R2_PUBLIC_URL: ${{ vars.R2_PUBLIC_URL || '' }}

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}

    - name: Create project directory
      run: |
        echo "Creating project directory structure..."
        mkdir -p projects/${{ inputs.project_id }}/src
        mkdir -p projects/${{ inputs.project_id }}/public
        mkdir -p artifacts/${{ inputs.project_id }}
        
        echo "Project directory created successfully"

    - name: Create source files from workflow input
      working-directory: projects/${{ inputs.project_id }}
      env:
        SOURCE_FILES: ${{ inputs.source_files }}
        BUILD_CONFIG: ${{ inputs.build_config }}
      run: |
        echo "Creating source files from workflow input..."
        echo "$SOURCE_FILES" > source_files.json
        
        # CRITICAL FIX: Use base64 encoding to handle all special characters reliably
        # This approach avoids all separator and newline issues
        echo "Processing source files with base64 encoding for reliability..."
        
        # Process each file using jq to extract key-value pairs
        # Use base64 encoding for content to handle newlines and special characters
        for filename in $(jq -r 'keys[]' source_files.json); do
          echo "Processing file: $filename"
          
          # Get the content and encode it in base64 to handle all special characters
          content=$(jq -r --arg key "$filename" '.[$key]' source_files.json | base64 -w 0)
          
          # Normalize filename
          filename=${filename#./}
          filename=${filename#/}

          # Basic safety: avoid path traversal
          if [[ "$filename" == *".."* ]]; then
            echo "Skipping unsafe path: $filename"
            continue
          fi

          # Decide target path
          if [[ "$filename" == public/* ]]; then
            target="$filename"
          elif [[ "$filename" == src/* ]]; then
            target="$filename"
          elif [[ "$filename" == "index.html" ]]; then
            # Place index.html in project root for Vite
            target="index.html"
          else
            target="src/$filename"
          fi

          # Create directory if needed
          mkdir -p "$(dirname "$target")"
          
          # Decode base64 and write to file
          echo "$content" | base64 -d > "$target"
          
          # Verify file was created and show line count
          if [ -f "$target" ]; then
            line_count=$(wc -l < "$target")
            echo "✓ Created: $target ($line_count lines)"
          else
            echo "✗ Failed to create: $target"
            exit 1
          fi
        done
        
        # Create package.json from build_config if not already created
        if [ ! -f "package.json" ]; then
          echo "Creating package.json from build_config..."
          echo "$BUILD_CONFIG" > package.json
          echo "✓ Created: package.json"
        fi
        
        # Clean up temporary file
        rm source_files.json
        
        echo "==============================================="
        echo "Source files created successfully"
        echo "==============================================="
        echo "Project structure:"
        ls -la
        if [ -d "src" ]; then
          echo ""
          echo "Source directory contents:"
          ls -la src/
        fi

    - name: Install dependencies
      working-directory: projects/${{ inputs.project_id }}
      run: |
        echo "Installing dependencies..."
        npm install --no-audit --no-fund
        echo "Dependencies installed successfully"

    - name: Create build configuration
      working-directory: projects/${{ inputs.project_id }}
      run: |
        echo "Setting up build environment..."
        
        # CRITICAL FIX: Ensure index.html exists in project root for Vite
        if [ ! -f "index.html" ]; then
          if [ -f "public/index.html" ]; then
            echo "Moving index.html from public/ to project root for Vite..."
            mv public/index.html index.html
          else
            echo "Creating default index.html in project root..."
            printf '%s\n' \
              '<!DOCTYPE html>' \
              '<html lang="en">' \
              '<head>' \
              '  <meta charset="UTF-8">' \
              '  <meta name="viewport" content="width=device-width, initial-scale=1.0">' \
              '  <title>GPTHost Build</title>' \
              '</head>' \
              '<body>' \
              '  <div id="root"></div>' \
              '  <script type="module" src="/src/main.jsx"></script>' \
              '</body>' \
              '</html>' > index.html
          fi
        fi
        
        # Update index.html to reference the correct entry point
        if [ -f "index.html" ] && [ -f "src/main.jsx" ]; then
          if ! grep -q 'src/main.jsx' index.html; then
            echo "Updating index.html to reference src/main.jsx..."
            sed -i 's|</body>|  <script type="module" src="/src/main.jsx"></script>\n</body>|' index.html
          fi
        fi
        
        # Create vite config if missing
        if [ ! -f "vite.config.js" ] && [ ! -f "vite.config.ts" ]; then
          printf '%s\n' \
            "import { defineConfig } from 'vite'" \
            "import react from '@vitejs/plugin-react'" \
            "" \
            "export default defineConfig({" \
            "  plugins: [react()]," \
            "  build: {" \
            "    outDir: 'dist'," \
            "    emptyOutDir: true" \
            "  }" \
            "})" > vite.config.js
        fi
        
        echo "Build configuration ready"
        echo "Project structure:"
        ls -la

    - name: Build project
      working-directory: projects/${{ inputs.project_id }}
      run: |
        echo "Building project..."
        
        # Run build and capture exit code
        BUILD_EXIT_CODE=0
        npm run build || BUILD_EXIT_CODE=$?
        
        if [ $BUILD_EXIT_CODE -ne 0 ]; then
          echo "==============================================="
          echo "BUILD FAILED with exit code: $BUILD_EXIT_CODE"
          echo "==============================================="
          echo "Build output above shows the error details."
          echo "This is a critical failure - no files will be uploaded."
          exit 1
        fi
        
        echo "Build completed successfully"
        
        # CRITICAL: Verify dist folder exists and has content
        echo "==============================================="
        echo "VERIFYING BUILD OUTPUT:"
        echo "==============================================="
        
        if [ ! -d "dist" ]; then
          echo "✗ CRITICAL ERROR: dist folder does not exist after build!"
          echo "Build command succeeded but produced no output."
          exit 1
        fi
        
        echo "✓ dist folder exists"
        echo "Contents of dist folder:"
        ls -la dist/
        
        # Check for index.html
        if [ ! -f "dist/index.html" ]; then
          echo "✗ CRITICAL ERROR: dist/index.html not found!"
          echo "Build output is incomplete."
          exit 1
        fi
        
        echo "✓ dist/index.html found"
        
        # Check for JS assets
        if ! find dist -name "*.js" -type f | grep -q .; then
          echo "⚠ WARNING: No JavaScript files found in dist/"
          echo "This might indicate a build problem."
        fi
        
        echo "==============================================="
        echo "Build verification completed successfully"

    - name: Prepare artifacts
      run: |
        echo "==============================================="
        echo "PREPARING ARTIFACTS FOR UPLOAD:"
        echo "==============================================="
        
        # CRITICAL: Only copy dist contents, nothing else
        if [ ! -d "projects/${{ inputs.project_id }}/dist" ]; then
          echo "✗ ERROR: dist folder not found"
          exit 1
        fi
        
        echo "✓ Found dist folder"
        echo "Copying ONLY dist contents to artifacts..."
        
        # Clear artifacts directory first to ensure no source files
        rm -rf artifacts/${{ inputs.project_id }}/*
        mkdir -p artifacts/${{ inputs.project_id }}
        
        # Copy only dist contents
        cp -r projects/${{ inputs.project_id }}/dist/* artifacts/${{ inputs.project_id }}/
        
        # Verify no source files were copied
        if [ -f "artifacts/${{ inputs.project_id }}/App.jsx" ] || \
           [ -f "artifacts/${{ inputs.project_id }}/main.jsx" ] || \
           [ -f "artifacts/${{ inputs.project_id }}/package.json" ]; then
          echo "✗ ERROR: Source files found in artifacts!"
          echo "This indicates the build didn't properly compile the files."
          ls -la artifacts/${{ inputs.project_id }}/
          exit 1
        fi
        
        echo "✓ Verified no source files in artifacts"
        
        # Create build manifest
        jq -n \
          --arg pid "${{ inputs.project_id }}" \
          --arg ts  "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
          --arg run "${{ github.run_id }}" \
          '{project_id:$pid, build_timestamp:$ts, workflow_run:$run, status:"completed"}' \
          > artifacts/${{ inputs.project_id }}/build-manifest.json
        
        echo "==============================================="
        echo "FINAL ARTIFACTS TO BE UPLOADED:"
        echo "==============================================="
        echo "Files in artifacts/${{ inputs.project_id }}:"
        find artifacts/${{ inputs.project_id }} -type f | head -20
        echo ""
        echo "Total size of artifacts:"
        du -sh artifacts/${{ inputs.project_id }}/
        echo "==============================================="

    - name: Upload to Cloudflare R2
      if: success()
      working-directory: artifacts/${{ inputs.project_id }}
      env:
        CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
        R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
        R2_BUCKET_NAME: ${{ secrets.R2_BUCKET_NAME }}
        R2_PUBLIC_URL: ${{ env.R2_PUBLIC_URL }}
      run: |
        echo "==============================================="
        echo "UPLOADING TO CLOUDFLARE R2:"
        echo "==============================================="
        
        if [ -z "$CLOUDFLARE_ACCOUNT_ID" ] || [ -z "$R2_ACCESS_KEY_ID" ] || [ -z "$R2_SECRET_ACCESS_KEY" ] || [ -z "$R2_BUCKET_NAME" ]; then
          echo "✗ ERROR: Missing R2 credentials"
          echo "Please configure GitHub Secrets for R2 access"
          exit 1
        fi
        
        # Final verification before upload
        if [ ! -f "index.html" ]; then
          echo "✗ CRITICAL ERROR: index.html not found in upload directory!"
          echo "Current directory contents:"
          ls -la
          exit 1
        fi
        
        echo "✓ index.html found, proceeding with upload..."
        
        # Setup AWS CLI
        if ! command -v aws >/dev/null 2>&1; then
          echo "Installing AWS CLI..."
          curl -fsSL https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip -o awscliv2.zip
          unzip -q awscliv2.zip
          sudo ./aws/install
        fi
        
        ENDPOINT="https://$CLOUDFLARE_ACCOUNT_ID.r2.cloudflarestorage.com"
        export AWS_ACCESS_KEY_ID="$R2_ACCESS_KEY_ID"
        export AWS_SECRET_ACCESS_KEY="$R2_SECRET_ACCESS_KEY"
        export AWS_DEFAULT_REGION="auto"
        
        BUILD_TIMESTAMP=$(date -u +%Y-%m-%dT%H-%M-%SZ)
        BUILD_PATH="builds/${{ inputs.project_id }}/$BUILD_TIMESTAMP"
        
        echo "Uploading to: s3://$R2_BUCKET_NAME/$BUILD_PATH/"
        
        # Upload all files with proper paths
        aws s3 sync . "s3://$R2_BUCKET_NAME/$BUILD_PATH/dist/" \
          --endpoint-url "$ENDPOINT" \
          --region auto \
          --no-progress
        
        echo "✓ Upload completed successfully"
        echo "Files available at: $BUILD_PATH/dist/"
        
        # Store paths for callback
        echo "BUILD_PATH=$BUILD_PATH" >> $GITHUB_ENV
        echo "BUILD_TIMESTAMP=$BUILD_TIMESTAMP" >> $GITHUB_ENV

    - name: Send success callback
      if: success()
      run: |
        echo "Sending success callback..."
        
        # Include R2 information in callback
        R2_JSON=", \"r2_build_path\": \"${BUILD_PATH}\", \"public_url\": \"${R2_PUBLIC_URL}/${BUILD_PATH}/dist/\""
        
        BODY="{\"status\": \"success\", \"project_id\": \"${{ inputs.project_id }}\", \"github_run_id\": \"${{ github.run_id }}\", \"github_run_url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"$R2_JSON}"
        
        curl -X POST "${{ inputs.callback_url }}" \
          -H "Content-Type: application/json" \
          -H "Authorization: Bearer ${{ inputs.callback_token }}" \
          -d "$BODY"
        
        echo "Build and deployment completed successfully!"

    - name: Send failure callback
      if: failure()
      run: |
        echo "Sending failure callback..."
        
        BODY="{\"status\": \"failed\", \"project_id\": \"${{ inputs.project_id }}\", \"github_run_id\": \"${{ github.run_id }}\", \"github_run_url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\", \"error\": \"Build or upload failed - check workflow logs\"}"
        
        curl -X POST "${{ inputs.callback_url }}" \
          -H "Content-Type: application/json" \
          -H "Authorization: Bearer ${{ inputs.callback_token }}" \
          -d "$BODY"
        
        echo "Build failed - callback sent"
