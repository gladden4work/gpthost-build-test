name: GPTHost Build Pipeline (Worker Upload)
# This workflow builds projects and sends artifacts to Worker for R2 upload
# GitHub Actions cannot upload to R2 directly due to secret masking of account IDs

on:
  workflow_dispatch:
    inputs:
      project_id:
        description: Project ID
        required: true
        type: string
      source_files:
        description: JSON object of files (path -> content)
        required: true
        type: string
      callback_url:
        description: Worker v2 callback URL
        required: true
        type: string
      callback_token:
        description: Bearer token for callback
        required: true
        type: string
      framework:
        description: Framework type (react|vue|svelte|auto)
        required: false
        type: string
        default: 'auto'
      build_command:
        description: Custom build command (optional, ignored by minimal flow)
        required: false
        type: string
      build_config:
        description: Optional build config JSON (ignored by minimal flow)
        required: false
        type: string
      correlation_id:
        description: Correlation ID for tracing (optional)
        required: false
        type: string

permissions:
  contents: read

env:
  NODE_VERSION: '20'
  PROJECT_ID: ${{ inputs.project_id }}
  FRAMEWORK: ${{ inputs.framework }}
  CALLBACK_URL: ${{ inputs.callback_url }}
  CALLBACK_TOKEN: ${{ inputs.callback_token }}

concurrency:
  group: build-${{ github.event.inputs.project_id }}
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install tools (jq)
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq

      - name: Prepare workspace
        run: |
          set -euo pipefail
          mkdir -p "projects/${{ inputs.project_id }}/src"
          mkdir -p "projects/${{ inputs.project_id }}/public"
          mkdir -p "artifacts/${{ inputs.project_id }}"

      - name: Materialize source files
        working-directory: projects/${{ inputs.project_id }}
        env:
          SOURCE_FILES: ${{ inputs.source_files }}
        run: |
          set -euo pipefail
          echo "$SOURCE_FILES" > source.json
          jq -e . source.json >/dev/null
          jq -r 'to_entries[] | @base64' source.json | while read -r row; do
            key=$(echo "$row" | base64 --decode | jq -r '.key')
            content=$(echo "$row" | base64 --decode | jq -r '.value')
            key="${key#./}"
            case "$key" in
              *".."*) echo "Skipping unsafe path: $key" >&2; continue ;;
            esac
            case "$key" in
              package.json|vite.config.js|vite.config.ts|vite.config.mjs|vite.config.cjs|tsconfig.json|tsconfig.node.json)
                target="$key" ;;
              public/*|src/*|index.html) target="$key" ;;
              *) target="src/$key" ;;
            esac
            mkdir -p "$(dirname "$target")"
            printf "%s" "$content" > "$target"
            echo "Created: $target"
          done
          if [ ! -f index.html ]; then
            printf '%s\n' \
              '<!DOCTYPE html>' \
              '<html lang="en">' \
              '  <head>' \
              '    <meta charset="UTF-8" />' \
              '    <meta name="viewport" content="width=device-width, initial-scale=1.0" />' \
              '    <title>GPTHost Minimal</title>' \
              '  </head>' \
              '  <body>' \
              '    <div id="root">GPTHost Minimal Build</div>' \
              '  </body>' \
              '</html>' > index.html
          fi

      - name: Scaffold framework application
        working-directory: projects/${{ inputs.project_id }}
        run: |
          set -euo pipefail
          echo "Scaffolding framework application..."
          node ../../.github/scripts/scaffold.js
          echo "Scaffolding complete"
          
          # Show the resulting structure
          echo "Project structure:"
          ls -la
          if [ -d "src" ]; then
            echo "Source directory:"
            ls -la src/
          fi
          
          echo "Package.json contents:"
          cat package.json 2>/dev/null || echo "No package.json"

      - name: Enforce relative base for Vite (subpath-safe)
        working-directory: projects/${{ inputs.project_id }}
        run: |
          set -euo pipefail
          # Some uploads provide their own vite.config.* without base './'.
          # Patch it to avoid absolute '/assets' in dist/index.html and dynamic imports.
          node ../../scripts/ensure-relative-base.mjs || true

      - name: Honor root package.json and merge build_config
        working-directory: projects/${{ inputs.project_id }}
        env:
          BUILD_CONFIG: ${{ inputs.build_config }}
        run: |
          set -euo pipefail
          # Merge optional build_config (package.json-like) into root package.json if provided
          if [ -n "${BUILD_CONFIG:-}" ] && echo "$BUILD_CONFIG" | jq -e . >/dev/null 2>&1; then
            echo "$BUILD_CONFIG" > build_config.raw.json
            jq . build_config.raw.json > build_config.json
            if [ ! -f package.json ]; then echo '{}' > package.json; fi
            jq -s '
              def md($a;$b): ($a//{}) as $A | ($b//{}) as $B | $A + $B;
              .[0] as $pkg | .[1] as $cfg |
              $pkg
              | .dependencies = md($pkg.dependencies; $cfg.dependencies)
              | .devDependencies = md($pkg.devDependencies; $cfg.devDependencies)
              | .peerDependencies = md($pkg.peerDependencies; $cfg.peerDependencies)
              | .scripts = md($pkg.scripts; $cfg.scripts)
            ' package.json build_config.json > package.merged.json
            mv package.merged.json package.json
            echo "Merged build_config into package.json"
            echo "Resulting package.json:"; cat package.json
          else
            echo "No valid build_config provided; skipping merge."
          fi

      - name: Ensure CSS config and dependencies
        working-directory: projects/${{ inputs.project_id }}
        run: |
          set -euo pipefail
          echo "Ensuring CSS entry, PostCSS config, and required deps..."
          # Helper: portable source scanner (uses ripgrep when available)
          scan() {
            local pattern="$1"; shift || true
            if command -v rg >/dev/null 2>&1; then
              rg -q -n -S -e "$pattern" "$@" 2>/dev/null
            else
              grep -R -q -n -E "$pattern" ${*:-.} 2>/dev/null
            fi
          }
          # Create empty package.json if missing (allows jq mutations below)
          if [ ! -f package.json ]; then echo '{}' > package.json; fi

          has_index_css=false
          if [ -f src/index.css ]; then
            has_index_css=true
          elif [ -f index.css ]; then
            mkdir -p src
            mv index.css src/index.css
            has_index_css=true
          fi

          # Remove incorrectly placed PostCSS config created by some templates
          if [ -f src/postcss.config.js ]; then
            echo "Removing stray src/postcss.config.js (Vite expects root config)"
            rm -f src/postcss.config.js || true
          fi

          # Detect Tailwind-style utility classes directly in source code.
          # This covers uploads that only contain TSX/JSX files (no CSS yet),
          # like usecase/* components produced by GPTHost.
          tailwind_code_detected=false
          if scan "(class|className)\\s*=\\s*['\"]([^'\"]*\\b(md:|lg:|xl:)?(bg-|text-|from-|to-|via-|rounded|shadow|ring-|space-[xy]-|p[trblxy]?-|m[trblxy]?-|grid|flex|min-h-|max-w-|mx-auto|sticky|backdrop-blur|col-span|row-span)" src usecase components index.html; then
            tailwind_code_detected=true
          fi

          # Helper to add or update a devDependency version in package.json via jq
          add_dev_dep() {
            local name="$1"; local version="$2"
            tmp=$(mktemp)
            jq --arg n "$name" --arg v "$version" '
              .devDependencies = (.devDependencies // {}) |
              .devDependencies[$n] = $v
            ' package.json > "$tmp" && mv "$tmp" package.json
            echo "Added devDependency: $name@$version"
          }

          # Helper to add or update a dependency
          add_dep() {
            local name="$1"; local version="$2"
            tmp=$(mktemp)
            jq --arg n "$name" --arg v "$version" '
              .dependencies = (.dependencies // {}) |
              .dependencies[$n] = $v
            ' package.json > "$tmp" && mv "$tmp" package.json
            echo "Added dependency: $name@$version"
          }

          if $has_index_css || $tailwind_code_detected; then
            # Detect Tailwind usage and ensure tailwindcss + config
            if scan "^@tailwind\\s+base;|^@tailwind\\s+components;|^@tailwind\\s+utilities;" src/index.css || $tailwind_code_detected; then
              if ! jq -e '.devDependencies["tailwindcss"]' package.json >/dev/null 2>&1; then
                add_dev_dep tailwindcss ^3.4.17
              fi
              # Generate a minimal tailwind.config.ts if missing
              if [ ! -f tailwind.config.ts ] && [ ! -f tailwind.config.js ]; then
                printf "%s\n" \
                  "import type { Config } from 'tailwindcss'" \
                  "" \
                  "export default {" \
                  "  content: [" \
                  "    './index.html'," \
                  "    './src/**/*.{js,jsx,ts,tsx,mdx}'," \
                  "    './components/**/*.{js,jsx,ts,tsx,mdx}'," \
                  "    './usecase/**/*.{js,jsx,ts,tsx,mdx}'" \
                  "  ]," \
                  "  theme: {" \
                  "    extend: {}," \
                  "  }," \
                  "  plugins: []," \
                  "} satisfies Config" \
                  > tailwind.config.ts
                echo "Created tailwind.config.ts"
              fi
              # Ensure src/index.css contains Tailwind directives if not already present
              if [ ! -f src/index.css ] || ! scan "^@tailwind\\s+base;" src/index.css; then
                mkdir -p src
                {
                  echo "@tailwind base;";
                  echo "@tailwind components;";
                  echo "@tailwind utilities;";
                } > src/index.css
                echo "Wrote Tailwind directives to src/index.css"
                has_index_css=true
              fi
            fi

            # Detect framework CSS imports and ensure packages
            if scan "modern-normalize" src/index.css; then
              if ! jq -e '.devDependencies["modern-normalize"] // .dependencies["modern-normalize"]' package.json >/dev/null 2>&1; then
                add_dev_dep modern-normalize ^1.1.0
              fi
            fi
            if scan "bootstrap/.+\\.css" src/index.css; then
              if ! jq -e '.dependencies["bootstrap"] // .devDependencies["bootstrap"]' package.json >/dev/null 2>&1; then
                add_dep bootstrap ^5.3.3
              fi
            fi
            if scan "bulma/.+\\.css" src/index.css; then
              if ! jq -e '.dependencies["bulma"] // .devDependencies["bulma"]' package.json >/dev/null 2>&1; then
                add_dep bulma ^1.0.0
              fi
            fi
            # Additional common CSS frameworks
            if scan "materialize-css/.+\\.css|materialize\\.min\\.css" src/index.css; then
              if ! jq -e '.dependencies["materialize-css"] // .devDependencies["materialize-css"]' package.json >/dev/null 2>&1; then
                add_dep materialize-css ^1.0.0
              fi
            fi
            if scan "foundation-sites/.+\\.css|foundation\\.min\\.css" src/index.css; then
              if ! jq -e '.dependencies["foundation-sites"] // .devDependencies["foundation-sites"]' package.json >/dev/null 2>&1; then
                add_dep foundation-sites ^6.7.0
              fi
            fi
            if scan "semantic-ui-css/.+\\.css|semantic\\.min\\.css" src/index.css; then
              if ! jq -e '.dependencies["semantic-ui-css"] // .devDependencies["semantic-ui-css"]' package.json >/dev/null 2>&1; then
                add_dep semantic-ui-css ^2.5.0
              fi
            fi
            if scan "normalize\\.css" src/index.css; then
              if ! jq -e '.devDependencies["normalize.css"] // .dependencies["normalize.css"]' package.json >/dev/null 2>&1; then
                add_dev_dep normalize.css ^8.0.1
              fi
            fi
            # Icon font CSS packages
            if scan "bootstrap-icons/.+\\.css|bootstrap-icons\\.css" src/index.css; then
              if ! jq -e '.dependencies["bootstrap-icons"] // .devDependencies["bootstrap-icons"]' package.json >/dev/null 2>&1; then
                add_dep bootstrap-icons ^1.11.3
              fi
            fi
            if scan "@fortawesome/fontawesome-free/.+\\.css|all\\.min\\.css" src/index.css; then
              if ! jq -e '.dependencies["@fortawesome/fontawesome-free"] // .devDependencies["@fortawesome/fontawesome-free"]' package.json >/dev/null 2>&1; then
                add_dep @fortawesome/fontawesome-free ^6.5.2
              fi
            fi
          fi

          # Auto-detect SCSS usage across sources and ensure sass
          if scan "\\.(scss|sass)\"|\\.(scss|sass)\'|@import[^;]*\\.(scss|sass)" src index.html || scan "\\.(scss|sass)$" src; then
            if ! jq -e '.devDependencies["sass"] // .dependencies["sass"]' package.json >/dev/null 2>&1; then
              add_dev_dep sass ^1.77.6
            fi
          fi

          # Ensure base PostCSS plugins are present when we write postcss.config.js
          if ! jq -e '.devDependencies["postcss-import"] // .dependencies["postcss-import"]' package.json >/dev/null 2>&1; then
            add_dev_dep postcss-import ^15.1.0
          fi
          if ! jq -e '.devDependencies["autoprefixer"] // .dependencies["autoprefixer"]' package.json >/dev/null 2>&1; then
            add_dev_dep autoprefixer ^10.4.21
          fi

          # Always ensure a valid PostCSS config exists, with optional tailwindcss
          include_tailwind=false
          tailwind_plugin_name='tailwindcss'
          if jq -e '.devDependencies["tailwindcss"] // .dependencies["tailwindcss"]' package.json >/dev/null 2>&1; then
            include_tailwind=true
            tv=$(jq -r '.devDependencies["tailwindcss"] // .dependencies["tailwindcss"]' package.json)
            # If Tailwind v4 is specified, prefer the new @tailwindcss/postcss plugin
            case "$tv" in
              4.*|^4*|~4*|>=4*|*x*|*latest*) tailwind_plugin_name='@tailwindcss/postcss' ;;
              *) tailwind_plugin_name='tailwindcss' ;;
            esac
            if [ "$tailwind_plugin_name" = "@tailwindcss/postcss" ]; then
              if ! jq -e '.devDependencies["@tailwindcss/postcss"] // .dependencies["@tailwindcss/postcss"]' package.json >/dev/null 2>&1; then
                add_dev_dep @tailwindcss/postcss ^4.0.0
              fi
            fi
          fi

          # Write postcss.config.js without heredocs to avoid YAML indentation issues
          printf "%s\n" \
            "export default {" \
            "  plugins: {" \
            "    'postcss-import': {}," \
            > postcss.config.js
          if $include_tailwind; then
            printf "    '%s': {},\n" "$tailwind_plugin_name" >> postcss.config.js
          fi
          printf "%s\n" \
            "    'autoprefixer': {}" \
            "  }" \
            "}" \
            >> postcss.config.js
          echo "Ensured valid postcss.config.js (tailwind: ${include_tailwind}, plugin: ${tailwind_plugin_name})"

          # Ensure src/index.css exists at minimum to avoid Vite CSS pipeline confusion
          if [ "$has_index_css" = false ]; then
            mkdir -p src
            printf "/* Base styles placeholder */\n" > src/index.css
            echo "Created placeholder src/index.css"
          fi

      - name: Build project
        working-directory: projects/${{ inputs.project_id }}
        run: |
          set -euo pipefail
          echo "Building project..."
          echo "Framework: ${FRAMEWORK:-auto}"
          
          # Check if this is a framework project with package.json
          if [ -f "package.json" ] && grep -q '"build"' package.json; then
            echo "Installing dependencies..."
            if [ -f "package-lock.json" ]; then
              npm ci --no-audit --no-fund
            else
              npm install --no-audit --no-fund
            fi
            
            echo "Enforcing relative base for Vite (subpath-safe)..."
            if [ -f "${{ github.workspace }}/scripts/ensure-relative-base.mjs" ]; then
              node "${{ github.workspace }}/scripts/ensure-relative-base.mjs"
            else
              echo "⚠️ ensure-relative-base.mjs not found, skipping enforcement"
            fi
            
            echo "Running build..."
            npm run build
            
            # Verify build output
            if [ ! -d "dist" ] || [ -z "$(ls -A dist 2>/dev/null)" ]; then
              echo "ERROR: No build output found in dist/"
              exit 1
            fi
            
            # Check for root-relative paths and rewrite to relative
            if [ -f "dist/index.html" ]; then
              if grep -q 'src="/' dist/index.html || grep -q 'href="/' dist/index.html; then
                echo "⚠️ Found absolute paths in dist/index.html, fixing..."
                sed -i -e 's#src="/#src="./#g' -e 's#href="/#href="./#g' dist/index.html
                if grep -q 'src="/' dist/index.html || grep -q 'href="/' dist/index.html; then
                  echo "ERROR: Found root-relative URLs in index.html after rewrite"
                  exit 1
                fi
              else
                echo "✅ Paths are already relative"
              fi
            fi
          else
            echo "No framework detected, using static build..."
            rm -rf dist
            mkdir -p dist
            cp -f index.html dist/index.html
            if [ -d public ]; then cp -r public/. dist/; fi
            if [ -d src ]; then mkdir -p dist/src && cp -r src/. dist/src/; fi
            node ../../scripts/rewrite-root-paths.mjs dist
            if grep -R 'href="/' dist >/dev/null || grep -R 'src="/' dist >/dev/null || grep -R 'url(/' dist >/dev/null; then
              echo "ERROR: Found root-relative URLs after rewrite"
              exit 1
            fi
          fi
          
          test -f dist/index.html
          echo "Build output:"
          ls -la dist/

      - name: Prepare artifacts
        run: |
          set -euo pipefail
          cp -r "projects/${{ inputs.project_id }}/dist/." "artifacts/${{ inputs.project_id }}/"
          test -f "artifacts/${{ inputs.project_id }}/index.html"

      - name: Create tarball of build artifacts
        run: |
          set -euo pipefail
          echo "Creating tarball of build artifacts..."
          tar -czf "build-${{ inputs.project_id }}.tar.gz" -C artifacts "${{ inputs.project_id }}"
          ls -lh "build-${{ inputs.project_id }}.tar.gz"
          echo "ARTIFACT_SIZE=$(stat -c%s "build-${{ inputs.project_id }}.tar.gz")" >> $GITHUB_ENV

      - name: Upload artifacts to GitHub (for backup)
        uses: actions/upload-artifact@v4
        with:
          name: build-${{ inputs.project_id }}
          path: artifacts/${{ inputs.project_id }}/
          retention-days: 1

      - name: Send build artifacts to Worker for R2 upload
        env:
          CALLBACK_URL: ${{ inputs.callback_url }}
          CALLBACK_TOKEN: ${{ inputs.callback_token }}
        run: |
          set -euo pipefail
          echo "Sending build artifacts to Worker for R2 upload..."
          echo "This bypasses GitHub's secret masking by handling R2 upload in Worker"
          
          # Create the tar.gz in memory and send directly to Worker
          # Worker will handle R2 upload using its environment bindings
          tar -czf - -C artifacts "${{ inputs.project_id }}" | \
          curl -sS -X POST "$CALLBACK_URL/upload" \
            -H "Authorization: Bearer $CALLBACK_TOKEN" \
            -H "X-Project-ID: ${{ inputs.project_id }}" \
            -H "X-GitHub-Run-ID: ${{ github.run_id }}" \
            -H "X-GitHub-Run-URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            -H "X-Correlation-ID: ${{ inputs.correlation_id }}" \
            -H "X-Framework: ${FRAMEWORK:-auto}" \
            -H "Content-Type: application/tar+gzip" \
            --data-binary @- \
            -o response.json
          
          # Check response from Worker
          if jq -e '.success' response.json > /dev/null; then
            echo "✅ Build artifacts successfully sent to Worker"
            echo "Worker will now handle R2 upload with native bindings"
            jq . response.json
            # Capture R2 path from response for accurate success callback
            R2_PATH=$(jq -r '.r2_path // .data.r2_path // empty' response.json)
            if [ -n "${R2_PATH}" ]; then
              echo "R2_PATH=${R2_PATH}" >> $GITHUB_ENV
              echo "Detected R2 path from upload response: ${R2_PATH}"
            else
              echo "WARNING: R2 path not found in upload response; will fall back to builds/${{ inputs.project_id }}/dist/"
            fi
          else
            echo "❌ Failed to send artifacts to Worker"
            jq . response.json
            exit 1
          fi

      - name: Success callback
        if: success()
        env:
          CALLBACK_URL: ${{ inputs.callback_url }}
          CALLBACK_TOKEN: ${{ inputs.callback_token }}
        run: |
          set -euo pipefail
          echo "Sending success callback to Worker..."
          # Prefer R2 path returned by upload step; fallback to legacy dist path
          R2_PATH_VALUE=${R2_PATH:-}
          if [ -z "${R2_PATH_VALUE}" ]; then
            R2_PATH_VALUE="builds/${{ inputs.project_id }}/dist/"
          fi
          BODY=$(jq -n \
            --arg status "success" \
            --arg pid "${{ inputs.project_id }}" \
            --arg rid "${{ github.run_id }}" \
            --arg run_url "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            --arg framework "${FRAMEWORK:-auto}" \
            --arg r2_path "${R2_PATH_VALUE}" \
            '{status:$status, project_id:$pid, framework:$framework, github_run_id:$rid, github_run_url:$run_url, r2_build_path:$r2_path}')
          
          curl -sS -X POST "$CALLBACK_URL" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $CALLBACK_TOKEN" \
            -d "$BODY" \
            -o callback_response.json
          
          echo "✅ Success callback sent to Worker"
          echo "Callback response:"
          jq . callback_response.json 2>/dev/null || cat callback_response.json

      - name: Failure callback
        if: failure()
        env:
          CALLBACK_URL: ${{ inputs.callback_url }}
          CALLBACK_TOKEN: ${{ inputs.callback_token }}
        run: |
          set -euo pipefail
          BODY=$(jq -n \
            --arg status "failure" \
            --arg pid "${{ inputs.project_id }}" \
            --arg rid "${{ github.run_id }}" \
            --arg run_url "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            --arg framework "${FRAMEWORK:-auto}" \
            '{status:$status, project_id:$pid, framework:$framework, github_run_id:$rid, github_run_url:$run_url}')
          curl -sS -X POST "$CALLBACK_URL" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $CALLBACK_TOKEN" \
            -d "$BODY"
