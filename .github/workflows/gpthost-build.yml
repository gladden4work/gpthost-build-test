name: GPTHost Build Pipeline - FIXED

on:
  workflow_dispatch:
    inputs:
      project_id:
        description: 'Project ID'
        required: true
        type: string
      source_files:
        description: 'Source files as JSON object'
        required: true
        type: string
      build_config:
        description: 'Build configuration (package.json content)'
        required: true
        type: string
      callback_url:
        description: 'Callback URL for build status'
        required: true
        type: string
      callback_token:
        description: 'Authentication token for callback'
        required: true
        type: string

env:
  NODE_VERSION: '20'
  PROJECT_ID: ${{ inputs.project_id }}
  CALLBACK_URL: ${{ inputs.callback_url }}
  CALLBACK_TOKEN: ${{ inputs.callback_token }}
  CACHE_VERSION: ${{ vars.CACHE_VERSION || '1' }}
  R2_PUBLIC_URL: ${{ vars.R2_PUBLIC_URL || '' }}

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}

    - name: Create project directory
      run: |
        echo "Creating project directory structure..."
        mkdir -p projects/${{ inputs.project_id }}/src
        mkdir -p projects/${{ inputs.project_id }}/public
        mkdir -p artifacts/${{ inputs.project_id }}
        
        echo "Project directory created successfully"

    - name: Create source files from workflow input
      working-directory: projects/${{ inputs.project_id }}
      env:
        SOURCE_FILES: ${{ inputs.source_files }}
        BUILD_CONFIG: ${{ inputs.build_config }}
      run: |
        echo "Creating source files from workflow input..."
        
        # CRITICAL FIX: Handle the source files as a string that might need escaping
        # First, we need to properly handle the JSON that might have unescaped characters
        
        # Method 1: Try to parse as-is (might work if properly escaped)
        if echo "$SOURCE_FILES" | jq -e . >/dev/null 2>&1; then
          echo "Source files JSON is valid, processing normally..."
          echo "$SOURCE_FILES" > source_files.json
        else
          echo "Source files JSON needs fixing, attempting to repair..."
          
          # Method 2: Try to fix common issues
          # Replace literal newlines with \n, handle other escaping issues
          SOURCE_FILES_FIXED=$(echo "$SOURCE_FILES" | sed 's/\\\\/\\/g')
          
          if echo "$SOURCE_FILES_FIXED" | jq -e . >/dev/null 2>&1; then
            echo "Fixed JSON is valid, using repaired version..."
            echo "$SOURCE_FILES_FIXED" > source_files.json
          else
            echo "ERROR: Unable to parse source files JSON even after attempting repairs"
            echo "Raw input (first 500 chars): ${SOURCE_FILES:0:500}"
            
            # Fallback: Try Python to handle the JSON
            echo "Attempting Python fallback for JSON parsing..."
            python3 -c "
import json
import sys
import os

try:
    # Try to parse the JSON from environment variable
    source_files_raw = os.environ.get('SOURCE_FILES', '{}')
    
    # Attempt to fix common issues
    # Remove backslash before exclamation marks
    source_files_raw = source_files_raw.replace('\\\\!', '!')
    
    # Parse the JSON
    source_files = json.loads(source_files_raw)
    
    # Write to file
    with open('source_files.json', 'w') as f:
        json.dump(source_files, f)
    
    print('Successfully parsed source files with Python')
    sys.exit(0)
except Exception as e:
    print(f'Python parsing also failed: {e}')
    sys.exit(1)
" || {
              echo "FATAL: Could not parse source files in any way"
              echo "This is likely due to improperly escaped special characters in the input"
              exit 1
            }
          fi
        fi
        
        # Now process the validated JSON file
        echo "Processing source files..."
        
        # Read each file from the JSON and create it
        python3 -c "
import json
import os
import base64
from pathlib import Path

# Read the source files
with open('source_files.json', 'r') as f:
    source_files = json.load(f)

# Process each file
for filename, content in source_files.items():
    # Normalize filename
    filename = filename.lstrip('./')
    
    # Skip unsafe paths
    if '..' in filename:
        print(f'Skipping unsafe path: {filename}')
        continue
    
    # Determine target path
    if filename.startswith('public/'):
        target = filename
    elif filename.startswith('src/'):
        target = filename
    elif filename == 'index.html':
        target = 'index.html'
    else:
        target = f'src/{filename}'
    
    # Create directory if needed
    Path(target).parent.mkdir(parents=True, exist_ok=True)
    
    # Write the file
    with open(target, 'w') as f:
        f.write(content)
    
    # Verify and report
    if os.path.exists(target):
        line_count = len(content.splitlines())
        print(f'✓ Created: {target} ({line_count} lines)')
    else:
        print(f'✗ Failed to create: {target}')
        exit(1)

print('All source files created successfully')
"
        
        # Create package.json from build_config if not already created
        if [ ! -f "package.json" ]; then
          echo "Creating package.json from build_config..."
          
          # Similar safe parsing for build_config
          if echo "$BUILD_CONFIG" | jq -e . >/dev/null 2>&1; then
            echo "$BUILD_CONFIG" > package.json
          else
            # Try Python fallback for package.json too
            python3 -c "
import json
import os

try:
    build_config_raw = os.environ.get('BUILD_CONFIG', '{}')
    build_config = json.loads(build_config_raw)
    
    with open('package.json', 'w') as f:
        json.dump(build_config, f, indent=2)
    
    print('✓ Created: package.json')
except Exception as e:
    print(f'Failed to create package.json: {e}')
    exit(1)
"
          fi
        fi
        
        # Clean up temporary file
        [ -f source_files.json ] && rm source_files.json
        
        echo "==============================================="
        echo "Source files created successfully"
        echo "==============================================="
        echo "Project structure:"
        ls -la
        if [ -d "src" ]; then
          echo ""
          echo "Source directory contents:"
          ls -la src/
        fi

    - name: Install dependencies
      working-directory: projects/${{ inputs.project_id }}
      run: |
        echo "Installing dependencies..."
        npm install --no-audit --no-fund
        echo "Dependencies installed successfully"

    - name: Create build configuration
      working-directory: projects/${{ inputs.project_id }}
      run: |
        echo "Setting up build environment..."
        
        # CRITICAL FIX: Ensure index.html exists in project root for Vite
        if [ ! -f "index.html" ]; then
          if [ -f "public/index.html" ]; then
            echo "Moving index.html from public/ to project root for Vite..."
            mv public/index.html index.html
          else
            echo "Creating default index.html in project root..."
            printf '%s\n' \
              '<!DOCTYPE html>' \
              '<html lang="en">' \
              '<head>' \
              '  <meta charset="UTF-8">' \
              '  <meta name="viewport" content="width=device-width, initial-scale=1.0">' \
              '  <title>GPTHost Build</title>' \
              '</head>' \
              '<body>' \
              '  <div id="root"></div>' \
              '  <script type="module" src="/src/main.jsx"></script>' \
              '</body>' \
              '</html>' > index.html
          fi
        fi
        
        # Update index.html to reference the correct entry point
        if [ -f "index.html" ] && [ -f "src/main.jsx" ]; then
          if ! grep -q 'src/main.jsx' index.html; then
            echo "Updating index.html to reference src/main.jsx..."
            sed -i 's|</body>|  <script type="module" src="/src/main.jsx"></script>\n</body>|' index.html
          fi
        fi
        
        # Create vite config if missing
        if [ ! -f "vite.config.js" ] && [ ! -f "vite.config.ts" ]; then
          printf '%s\n' \
            "import { defineConfig } from 'vite'" \
            "import react from '@vitejs/plugin-react'" \
            "" \
            "export default defineConfig({" \
            "  plugins: [react()]," \
            "  build: {" \
            "    outDir: 'dist'," \
            "    emptyOutDir: true" \
            "  }" \
            "})" > vite.config.js
        fi
        
        # Safety net: create fallback App.css if referenced but missing
        for app in src/App.jsx src/App.tsx; do
          if [ -f "$app" ] && grep -q "import './App.css'" "$app" && [ ! -f "src/App.css" ]; then
            echo "Creating fallback src/App.css..."
            printf '%s\n' ".App { text-align: center; }" > src/App.css
            echo "✓ Created fallback src/App.css"
          fi
        done

        echo "Build configuration ready"
        echo "Project structure:"
        ls -la

    - name: Build project
      working-directory: projects/${{ inputs.project_id }}
      run: |
        echo "Building project..."
        
        # Run build and capture exit code
        BUILD_EXIT_CODE=0
        npm run build || BUILD_EXIT_CODE=$?
        
        if [ $BUILD_EXIT_CODE -ne 0 ]; then
          echo "==============================================="
          echo "BUILD FAILED with exit code: $BUILD_EXIT_CODE"
          echo "==============================================="
          echo "Build output above shows the error details."
          echo "This is a critical failure - no files will be uploaded."
          exit 1
        fi
        
        echo "Build completed successfully"
        
        # CRITICAL: Verify dist folder exists and has content
        echo "==============================================="
        echo "VERIFYING BUILD OUTPUT:"
        echo "==============================================="
        
        if [ ! -d "dist" ]; then
          echo "✗ CRITICAL ERROR: dist folder does not exist after build!"
          echo "Build command succeeded but produced no output."
          exit 1
        fi
        
        echo "✓ dist folder exists"
        echo "Contents of dist folder:"
        ls -la dist/
        
        # Check for index.html
        if [ ! -f "dist/index.html" ]; then
          echo "✗ CRITICAL ERROR: dist/index.html not found!"
          echo "Build output is incomplete."
          exit 1
        fi
        
        echo "✓ dist/index.html found"
        
        # Check for JS assets
        if ! find dist -name "*.js" -type f | grep -q .; then
          echo "⚠ WARNING: No JavaScript files found in dist/"
          echo "This might indicate a build problem."
        fi
        
        echo "==============================================="
        echo "Build verification completed successfully"

    - name: Prepare artifacts
      run: |
        echo "==============================================="
        echo "PREPARING ARTIFACTS FOR UPLOAD:"
        echo "==============================================="
        
        # CRITICAL: Only copy dist contents, nothing else
        if [ ! -d "projects/${{ inputs.project_id }}/dist" ]; then
          echo "✗ ERROR: dist folder not found"
          exit 1
        fi
        
        echo "✓ Found dist folder"
        echo "Copying ONLY dist contents to artifacts..."
        
        # Clear artifacts directory first to ensure no source files
        rm -rf artifacts/${{ inputs.project_id }}/*
        mkdir -p artifacts/${{ inputs.project_id }}
        
        # Copy only dist contents
        cp -r projects/${{ inputs.project_id }}/dist/* artifacts/${{ inputs.project_id }}/
        
        # Verify no source files were copied
        if [ -f "artifacts/${{ inputs.project_id }}/App.jsx" ] || \
           [ -f "artifacts/${{ inputs.project_id }}/main.jsx" ] || \
           [ -f "artifacts/${{ inputs.project_id }}/package.json" ]; then
          echo "✗ ERROR: Source files found in artifacts!"
          echo "This indicates the build didn't properly compile the files."
          ls -la artifacts/${{ inputs.project_id }}/
          exit 1
        fi
        
        echo "✓ Verified no source files in artifacts"
        
        # Create build manifest
        jq -n \
          --arg pid "${{ inputs.project_id }}" \
          --arg ts  "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
          --arg run "${{ github.run_id }}" \
          '{project_id:$pid, build_timestamp:$ts, workflow_run:$run, status:"completed"}' \
          > artifacts/${{ inputs.project_id }}/build-manifest.json
        
        echo "==============================================="
        echo "FINAL ARTIFACTS TO BE UPLOADED:"
        echo "==============================================="
        echo "Files in artifacts/${{ inputs.project_id }}:"
        find artifacts/${{ inputs.project_id }} -type f | head -20
        echo ""
        echo "Total size of artifacts:"
        du -sh artifacts/${{ inputs.project_id }}/
        echo "==============================================="

    - name: Upload to Cloudflare R2
      if: success()
      working-directory: artifacts/${{ inputs.project_id }}
      env:
        CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
        R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
        R2_BUCKET_NAME: ${{ secrets.R2_BUCKET_NAME }}
        R2_PUBLIC_URL: ${{ env.R2_PUBLIC_URL }}
      run: |
        echo "==============================================="
        echo "UPLOADING TO CLOUDFLARE R2:"
        echo "==============================================="
        
        if [ -z "$CLOUDFLARE_ACCOUNT_ID" ] || [ -z "$R2_ACCESS_KEY_ID" ] || [ -z "$R2_SECRET_ACCESS_KEY" ] || [ -z "$R2_BUCKET_NAME" ]; then
          echo "✗ ERROR: Missing R2 credentials"
          echo "Please configure GitHub Secrets for R2 access"
          exit 1
        fi
        
        # Final verification before upload
        if [ ! -f "index.html" ]; then
          echo "✗ CRITICAL ERROR: index.html not found in upload directory!"
          echo "Current directory contents:"
          ls -la
          exit 1
        fi
        
        echo "✓ index.html found, proceeding with upload..."
        
        # Setup AWS CLI
        if ! command -v aws >/dev/null 2>&1; then
          echo "Installing AWS CLI..."
          curl -fsSL https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip -o awscliv2.zip
          unzip -q awscliv2.zip
          sudo ./aws/install
        fi
        
        ENDPOINT="https://$CLOUDFLARE_ACCOUNT_ID.r2.cloudflarestorage.com"
        export AWS_ACCESS_KEY_ID="$R2_ACCESS_KEY_ID"
        export AWS_SECRET_ACCESS_KEY="$R2_SECRET_ACCESS_KEY"
        export AWS_DEFAULT_REGION="auto"
        
        BUILD_TIMESTAMP=$(date -u +%Y-%m-%dT%H-%M-%SZ)
        BUILD_PATH="builds/${{ inputs.project_id }}/$BUILD_TIMESTAMP"
        
        echo "Uploading to: s3://$R2_BUCKET_NAME/$BUILD_PATH/"
        
        # Upload all files with proper paths (upload to $BUILD_PATH root)
        aws s3 sync . "s3://$R2_BUCKET_NAME/$BUILD_PATH/" \
          --endpoint-url "$ENDPOINT" \
          --region auto \
          --no-progress
        
        echo "✓ Upload completed successfully"
        echo "Files available at: $BUILD_PATH/"
        
        # Store paths for callback
        echo "BUILD_PATH=$BUILD_PATH" >> $GITHUB_ENV
        echo "BUILD_TIMESTAMP=$BUILD_TIMESTAMP" >> $GITHUB_ENV

    - name: Send success callback
      if: success()
      run: |
        echo "Sending success callback..."
        
        # Include R2 information in callback
        # Public URL should point to the build path root (no trailing /dist)
        R2_JSON=", \"r2_build_path\": \"${BUILD_PATH}\", \"public_url\": \"${R2_PUBLIC_URL}/${BUILD_PATH}/\", \"r2_bucket_name\": \"${R2_BUCKET_NAME}\", \"r2_endpoint\": \"${ENDPOINT}\", \"build_timestamp\": \"${BUILD_TIMESTAMP}\""
        
        # Small delay to avoid R2 listing race during auto-deploy
        sleep 4
        
        BODY="{\"status\": \"success\", \"project_id\": \"${{ inputs.project_id }}\", \"github_run_id\": \"${{ github.run_id }}\", \"github_run_url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"$R2_JSON}"
        
        curl -X POST "${{ inputs.callback_url }}" \
          -H "Content-Type: application/json" \
          -H "Authorization: Bearer ${{ inputs.callback_token }}" \
          -d "$BODY"
        
        echo "Build and deployment completed successfully!"

    - name: Send failure callback
      if: failure()
      run: |
        echo "Sending failure callback..."
        
        BODY="{\"status\": \"failed\", \"project_id\": \"${{ inputs.project_id }}\", \"github_run_id\": \"${{ github.run_id }}\", \"github_run_url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\", \"error\": \"Build or upload failed - check workflow logs\"}"
        
        curl -X POST "${{ inputs.callback_url }}" \
          -H "Content-Type: application/json" \
          -H "Authorization: Bearer ${{ inputs.callback_token }}" \
          -d "$BODY"
        
        echo "Build failed - callback sent"
