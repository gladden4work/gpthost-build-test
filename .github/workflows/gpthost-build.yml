name: GPTHost Build Pipeline (Minimal)

on:
  workflow_dispatch:
    inputs:
      project_id:
        description: 'Project ID'
        required: true
        type: string
      source_files:
        description: 'Source files as JSON object (path -> content)'
        required: true
        type: string
      callback_url:
        description: 'Callback URL for build status'
        required: true
        type: string
      callback_token:
        description: 'Authentication token for callback'
        required: true
        type: string
      correlation_id:
        description: 'Correlation ID (optional)'
        required: false
        type: string

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Prepare directories
        run: |
          set -euo pipefail
          mkdir -p projects/${{ inputs.project_id }}/src
          mkdir -p projects/${{ inputs.project_id }}/public
          mkdir -p artifacts/${{ inputs.project_id }}

      - name: Create source files (jq only)
        working-directory: projects/${{ inputs.project_id }}
        env:
          SOURCE_FILES: ${{ inputs.source_files }}
        run: |
          set -euo pipefail
          echo "$SOURCE_FILES" > source.json
          if ! jq -e . source.json >/dev/null 2>&1; then
            echo "Invalid JSON in source_files input" >&2
            exit 1
          fi

          jq -r 'to_entries[] | @base64' source.json | while read -r row; do
            key=$(echo "$row" | base64 --decode | jq -r '.key')
            content=$(echo "$row" | base64 --decode | jq -r '.value')

            # Normalize path
            key="${key#./}"
            if [[ "$key" == *".."* ]]; then
              echo "Skipping unsafe path: $key"
              continue
            fi

            # Determine target
            if [[ "$key" == public/* ]] || [[ "$key" == src/* ]] || [[ "$key" == "index.html" ]]; then
              target="$key"
            else
              target="src/$key"
            fi

            mkdir -p "$(dirname "$target")"
            printf "%s" "$content" > "$target"
            echo "Created: $target"
          done

          # Ensure index.html exists
          if [ ! -f index.html ]; then
            cat > index.html << 'HTML'
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GPTHost Minimal</title>
  </head>
  <body>
    <div id="root">GPTHost Minimal Build</div>
  </body>
  </html>
HTML
          fi

      - name: Minimal build (no Node toolchain)
        working-directory: projects/${{ inputs.project_id }}
        run: |
          set -euo pipefail
          rm -rf dist
          mkdir -p dist
          # Copy index and public assets
          cp -f index.html dist/index.html
          if [ -d public ]; then
            cp -r public/. dist/
          fi
          # Optionally include src as static assets (best effort)
          if [ -d src ]; then
            mkdir -p dist/src
            cp -r src/. dist/src/
          fi
          echo "Minimal static build prepared in dist/"

      - name: Prepare artifacts
        run: |
          set -euo pipefail
          if [ ! -f "projects/${{ inputs.project_id }}/dist/index.html" ]; then
            echo "dist/index.html missing" >&2
            exit 1
          fi
          cp -r "projects/${{ inputs.project_id }}/dist/." "artifacts/${{ inputs.project_id }}/"
          echo "Artifacts ready"

      - name: Upload to Cloudflare R2
        working-directory: artifacts/${{ inputs.project_id }}
        env:
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          R2_BUCKET_NAME: ${{ secrets.R2_BUCKET_NAME }}
          R2_PUBLIC_BASE_URL: ${{ secrets.R2_PUBLIC_BASE_URL }}
        run: |
          set -euo pipefail
          if [ -z "${CLOUDFLARE_ACCOUNT_ID:-}" ] || [ -z "${R2_ACCESS_KEY_ID:-}" ] || [ -z "${R2_SECRET_ACCESS_KEY:-}" ] || [ -z "${R2_BUCKET_NAME:-}" ]; then
            echo "Missing R2 credentials" >&2
            exit 1
          fi
          if ! command -v aws >/dev/null 2>&1; then
            curl -fsSL https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip -o awscliv2.zip
            unzip -q awscliv2.zip
            sudo ./aws/install
          fi
          ENDPOINT="https://${CLOUDFLARE_ACCOUNT_ID}.r2.cloudflarestorage.com"
          export AWS_ACCESS_KEY_ID="$R2_ACCESS_KEY_ID"
          export AWS_SECRET_ACCESS_KEY="$R2_SECRET_ACCESS_KEY"
          export AWS_DEFAULT_REGION="auto"
          BUILD_TIMESTAMP=$(date -u +%Y-%m-%dT%H-%M-%SZ)
          BUILD_PATH="builds/${{ inputs.project_id }}/$BUILD_TIMESTAMP"
          aws s3 sync . "s3://$R2_BUCKET_NAME/$BUILD_PATH/" --endpoint-url "$ENDPOINT" --region auto --no-progress
          echo "BUILD_PATH=$BUILD_PATH" >> $GITHUB_ENV
          echo "ENDPOINT=$ENDPOINT" >> $GITHUB_ENV
          echo "BUILD_TIMESTAMP=$BUILD_TIMESTAMP" >> $GITHUB_ENV

      - name: Send success callback
        env:
          CALLBACK_URL: ${{ inputs.callback_url }}
          CALLBACK_TOKEN: ${{ inputs.callback_token }}
          R2_PUBLIC_BASE_URL: ${{ secrets.R2_PUBLIC_BASE_URL }}
        run: |
          set -euo pipefail
          PUBLIC_URL=""
          if [ -n "${R2_PUBLIC_BASE_URL:-}" ]; then
            PUBLIC_URL="${R2_PUBLIC_BASE_URL}/${BUILD_PATH}/"
          fi
          BODY=$(jq -n \
            --arg status "success" \
            --arg pid "${{ inputs.project_id }}" \
            --arg run_id "${{ github.run_id }}" \
            --arg run_url "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            --arg r2_path "$BUILD_PATH" \
            --arg public_url "$PUBLIC_URL" \
            '{status:$status, project_id:$pid, github_run_id:$run_id, github_run_url:$run_url, r2_build_path:$r2_path, public_url:$public_url}')
          curl -sS -X POST "$CALLBACK_URL" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $CALLBACK_TOKEN" \
            -d "$BODY"
          echo "Callback sent"

      - name: Send failure callback
        if: failure()
        env:
          CALLBACK_URL: ${{ inputs.callback_url }}
          CALLBACK_TOKEN: ${{ inputs.callback_token }}
        run: |
          set -euo pipefail
          BODY=$(jq -n \
            --arg status "failed" \
            --arg pid "${{ inputs.project_id }}" \
            --arg run_id "${{ github.run_id }}" \
            --arg run_url "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            '{status:$status, project_id:$pid, github_run_id:$run_id, github_run_url:$run_url, error:"Build or upload failed"}')
          curl -sS -X POST "$CALLBACK_URL" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $CALLBACK_TOKEN" \
            -d "$BODY"
